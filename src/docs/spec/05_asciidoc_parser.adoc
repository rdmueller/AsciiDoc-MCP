:jbake-title: AsciiDoc Parser Specification
:jbake-type: page_toc
:jbake-status: published
:jbake-order: 5
ifndef::imagesdir[:imagesdir: ../../images]

:toc:

= AsciiDoc Parser - Component Specification
:sectnums:
:icons: font

== Introduction

This specification defines the **AsciiDocParser** - a lightweight component for parsing AsciiDoc documents. The parser is intentionally tailored to the requirements of this project and is not a complete Asciidoctor-compatible parser.

=== Purpose

The AsciiDocParser serves to:

1. **Capture document structure**: Extract sections and build hierarchical structure
2. **Resolve includes**: Process `include::[]` directives recursively with source mapping
3. **Identify elements**: Recognize code blocks, tables, images, admonitions, and PlantUML as addressable blocks
4. **Manage attributes**: Set document attributes and resolve them in paths/content
5. **Capture cross-references**: Collect `<<anchor>>` and `xref:[]` for link validation
6. **Source file mapping**: Capture line numbers and source file for each element

=== Scope Limitations

The parser is **not** a complete Asciidoctor renderer. It:

* Does not render HTML/PDF
* Does not parse inline formatting (bold, italic, monospace)
* Does not analyze table contents in detail
* Does not process complex list structures
* Does **not** support conditional blocks (`ifdef::`, `ifndef::`, `ifeval::`)

== Technical Debt

[WARNING]
====
**TD-ADOC-001: Conditional Blocks Not Supported**

The following AsciiDoc features are **not** supported in this version:

* `ifdef::attr[]` / `endif::[]`
* `ifndef::attr[]` / `endif::[]`
* `ifeval::[]`

These features are relevant for complex documentation projects with conditional output. A later implementation should:

1. Evaluate attribute-based conditions
2. Be able to show/hide conditional blocks
3. Handle nested conditions

**Priority:** Low (not required for MVP)
====

== Supported AsciiDoc Features

=== Fully Supported

[cols="2,3,2"]
|===
| Feature | Description | Usage

| **Sections**
| `= Title` to `====== Level 5`
| Document structure

| **Document Header**
| Title and attributes before first content
| Metadata

| **Document Attributes**
| `:attribute: value`
| Configuration, metadata

| **Attribute References**
| `{attribute}` in text and paths
| Dynamic values

| **Include Directive**
| `include::path[]` with attribute substitution
| Document composition

| **Source Blocks**
| `[source,language]` with `----`
| Element extraction

| **PlantUML Blocks**
| `[plantuml,name,format]` with `----`
| Element extraction

| **Images**
| `image::path[alt]` (block) and `image:path[alt]` (inline)
| Element extraction

| **Admonitions**
| `NOTE:`, `TIP:`, `WARNING:`, `CAUTION:`, `IMPORTANT:`
| Element extraction

| **Cross-References**
| `<<anchor>>` and `xref:file#anchor[]`
| Link capture
|===

=== Recognized (Not Parsed in Detail)

[cols="2,3,2"]
|===
| Feature | Description | Treatment

| **Tables**
| `\|===` block tables
| Recognized as block, content not analyzed

| **Listing Blocks**
| `----` without `[source]`
| Recognized as generic block

| **Sidebar Blocks**
| `****` blocks
| Recognized as block

| **Example Blocks**
| `====` blocks
| Recognized as block

| **Quote Blocks**
| `____` blocks
| Recognized as block
|===

=== Not Supported

* Conditional blocks (`ifdef::`, `ifndef::`, `ifeval::`) - see Technical Debt
* Inline formatting (`*bold*`, `_italic_`, `+mono+`)
* Footnotes
* Bibliography
* Index entries
* Complex table formatting (colspan, rowspan)
* Passthrough blocks (`++++`)

== Include Resolution

The AsciiDocParser supports recursive resolution of `include::[]` directives with complete source mapping.

=== Syntax

[source,asciidoc]
----
\include::path/to/file.adoc[]
\include::{includedir}/file.adoc[]
\include::chapter.adoc[leveloffset=+1]
\include::code.py[lines=5..10]
----

=== Attribute Substitution in Paths

Attributes are substituted **before** path resolution:

[source,asciidoc]
----
:includedir: chapters
:lang: en

\include::{includedir}/{lang}/intro.adoc[]
// Resolves to: chapters/en/intro.adoc
----

=== Include Options

[cols="2,3,2"]
|===
| Option | Description | Support

| `leveloffset=+n`
| Increase section level by n
| ✓ Full

| `leveloffset=-n`
| Decrease section level by n
| ✓ Full

| `lines=n..m`
| Include only lines n to m
| ✓ Full

| `tag=name`
| Include only tagged region
| ✗ Not supported

| `indent=n`
| Add indentation
| ✗ Not supported
|===

=== Source Mapping

For each element, the **original** source file and line number are captured:

[source,python]
----
@dataclass
class SourceLocation:
    """Position in source document."""
    file: Path              # Original file (not resolved include file)
    line: int               # 1-based line number in this file
    resolved_from: Path | None  # If included via include directive
----

=== Circular Includes

The parser detects and prevents circular include chains:

[source,gherkin]
----
Scenario: Circular includes are detected
  Given File A contains "include::B.adoc[]"
  And File B contains "include::A.adoc[]"
  When the parser processes File A
  Then a CircularIncludeError is thrown
  And the include chain is specified in the error
----

== Document Attributes

=== Syntax

[source,asciidoc]
----
// Set attribute
:author: John Doe
:revdate: 2024-01-15
:imagesdir: ./images

// Unset attribute
:!draft:

// Attribute reference
The author is {author}.
----

=== Standard Attributes

[cols="1,2,2"]
|===
| Attribute | Description | Default Value

| `doctype`
| Document type (article, book, etc.)
| `article`

| `imagesdir`
| Base path for images
| `.` (current directory)

| `includedir`
| Base path for includes
| `.` (current directory)

| `leveloffset`
| Global section level offset
| `0`
|===

=== jbake Attributes

For integration with jbake, the following attributes are extracted as metadata:

[source,asciidoc]
----
:jbake-title: My Document
:jbake-type: page_toc
:jbake-status: published
:jbake-menu: main
:jbake-order: 5
----

== Extractable Elements

=== Source Blocks (Code)

[source,asciidoc]
----
[source,python]
.Optional Title
----
def hello():
    print("Hello, World!")
----
----

.Extracted Information
[cols="1,2"]
|===
| Attribute | Value

| `type` | `code`
| `language` | `python`
| `title` | `Optional Title` (or empty)
| `source_location` | Source file and line number
| `content` | Raw content (without delimiter)
|===

=== PlantUML Blocks

[source,asciidoc]
-----
[plantuml, diagram-name, svg]
----
@startuml
Alice -> Bob: Hello
@enduml
----
-----

.Extracted Information
[cols="1,2"]
|===
| Attribute | Value

| `type` | `plantuml`
| `name` | `diagram-name`
| `format` | `svg`
| `source_location` | Source file and line number
| `content` | PlantUML source code
|===

=== Tables

[source,asciidoc]
----
.Table Title
[cols="1,2,3"]
|===
| Header 1 | Header 2 | Header 3

| Cell 1   | Cell 2   | Cell 3
|===
----

.Extracted Information
[cols="1,2"]
|===
| Attribute | Value

| `type` | `table`
| `title` | `Table Title` (or empty)
| `columns` | Number of columns (from cols attribute or header)
| `rows` | Number of data rows
| `source_location` | Source file and line number
|===

NOTE: Table contents are not parsed in detail. Only structural metadata is captured.

=== Images

[source,asciidoc]
----
// Block image
image::path/to/image.png[Alt Text, 400, 300]

// With title
.Image Title
image::diagram.svg[Architecture Diagram]
----

.Extracted Information
[cols="1,2"]
|===
| Attribute | Value

| `type` | `image`
| `src` | `path/to/image.png` (with resolved `{imagesdir}`)
| `alt` | `Alt Text`
| `title` | `Image Title` (or empty)
| `width` | `400` (or empty)
| `height` | `300` (or empty)
| `source_location` | Source file and line number
|===

=== Admonitions

[source,asciidoc]
----
NOTE: This is a note.

WARNING: This is a warning.

[TIP]
====
This is a multi-line tip.
With multiple paragraphs.
====
----

.Extracted Information
[cols="1,2"]
|===
| Attribute | Value

| `type` | `admonition`
| `admonition_type` | `NOTE`, `TIP`, `WARNING`, `CAUTION`, or `IMPORTANT`
| `source_location` | Source file and line number
| `content` | Admonition content (raw text)
|===

== Cross-References

The parser captures all cross-references for later link validation.

=== Syntax

[source,asciidoc]
----
// Internal reference
<<section-anchor>>
<<section-anchor,Custom Text>>

// External reference (xref)
xref:other-file.adoc#anchor[Link Text]
xref:other-file.adoc[]
----

=== Captured Information

[source,python]
----
@dataclass
class CrossReference:
    """A captured cross-reference."""
    type: Literal["internal", "external"]
    target: str                 # Anchor or file#anchor
    text: str | None           # Optional link text
    source_location: SourceLocation
----

== Data Models

=== AsciidocDocument

[source,python]
----
@dataclass
class AsciidocDocument:
    """Represents a parsed AsciiDoc document."""
    file_path: Path
    title: str
    attributes: dict[str, str]
    sections: list[AsciidocSection]
    elements: list[AsciidocElement]
    cross_references: list[CrossReference]
    includes: list[IncludeInfo]         # All resolved includes
----

=== AsciidocSection

[source,python]
----
@dataclass
class AsciidocSection:
    """A section in the document."""
    title: str
    level: int                          # 0-5 (0 = document title)
    anchor: str | None                  # [[anchor]] if present
    source_location: SourceLocation
    path: str                           # Hierarchical path
    children: list[AsciidocSection]
----

=== AsciidocElement

[source,python]
----
@dataclass
class AsciidocElement:
    """An extractable element."""
    type: Literal["code", "plantuml", "table", "image", "admonition"]
    source_location: SourceLocation
    attributes: dict[str, Any]          # Type-specific attributes
    parent_section: str                 # Path of containing section
----

=== IncludeInfo

[source,python]
----
@dataclass
class IncludeInfo:
    """Information about a resolved include."""
    source_location: SourceLocation     # Where the include is located
    target_path: Path                   # Resolved target path
    options: dict[str, str]             # leveloffset, lines, etc.
----

== Parser Behavior

=== Attribute Resolution

Attributes are resolved **during** parsing:

1. Set standard attributes (`doctype`, `imagesdir`, etc.)
2. Parse and set header attributes
3. For each attribute reference `{name}`, insert the current value
4. Treat unknown attributes as empty string (with warning)

=== Error Handling

[cols="2,3"]
|===
| Situation | Behavior

| Include file not found
| `IncludeNotFoundError` with path and source file

| Circular include
| `CircularIncludeError` with include chain

| Invalid attribute syntax
| Log warning, ignore line

| Invalid UTF-8 encoding
| `EncodingError` with file hint

| Empty file
| Return empty document (no sections)

| File without sections
| Entire content as implicit root section
|===

=== Performance Requirements

* Parsing a single file (without includes): < 50ms
* Parsing a document with 50 include files: < 2s
* Memory consumption: < 10KB per parsed file (without content)
* Include depth: max. 20 levels (configurable)

== Acceptance Criteria

=== AC-ADOC-01: Section Extraction

[source,gherkin]
----
Scenario: Sections are correctly extracted
  Given an AsciiDoc file with the following content:
    """
    = Main Title

    == Chapter 1

    Text...

    == Chapter 2

    === Subchapter
    """
  When the parser processes the file
  Then 4 sections are extracted
  And the hierarchy is:
    | path                        | level |
    | /main-title                 | 0     |
    | /main-title/chapter-1       | 1     |
    | /main-title/chapter-2       | 1     |
    | /main-title/chapter-2/subchapter | 2 |
----

=== AC-ADOC-02: Attribute Resolution

[source,gherkin]
----
Scenario: Attributes are correctly resolved
  Given an AsciiDoc file with the following content:
    """
    :author: John Doe
    :project: MCP Server

    = {project} Documentation

    Author: {author}
    """
  When the parser processes the file
  Then the document title is "MCP Server Documentation"
  And attributes["author"] is "John Doe"
----

=== AC-ADOC-03: Include Resolution

[source,gherkin]
----
Scenario: Includes are recursively resolved
  Given a main file "main.adoc":
    """
    = Main Document

    \include::chapter.adoc[leveloffset=+1]
    """
  And an include file "chapter.adoc":
    """
    = Chapter

    Chapter content.
    """
  When the parser processes "main.adoc"
  Then the document contains 2 sections
  And the section "Chapter" has level 1 (due to leveloffset)
  And the source_location of "Chapter" points to "chapter.adoc"
----

=== AC-ADOC-04: Circular Include Detection

[source,gherkin]
----
Scenario: Circular includes are detected
  Given a file "a.adoc" with "include::b.adoc[]"
  And a file "b.adoc" with "include::a.adoc[]"
  When the parser processes "a.adoc"
  Then a CircularIncludeError is thrown
  And the error message contains "a.adoc -> b.adoc -> a.adoc"
----

=== AC-ADOC-05: Source Block Extraction

[source,gherkin]
----
Scenario: Source blocks are extracted
  Given an AsciiDoc file with a Python source block
  When the parser processes the file
  Then elements contains an entry of type "code"
  And its language equals "python"
  And source_location points to the correct file and line
----

=== AC-ADOC-06: PlantUML Extraction

[source,gherkin]
----
Scenario: PlantUML blocks are extracted as their own type
  Given an AsciiDoc file with:
    """
    [plantuml, my-diagram, svg]
    ----
    @startuml
    A -> B
    @enduml
    ----
    """
  When the parser processes the file
  Then elements contains an entry of type "plantuml"
  And name equals "my-diagram"
  And format equals "svg"
----

=== AC-ADOC-07: Admonition Extraction

[source,gherkin]
----
Scenario: Admonitions are extracted
  Given an AsciiDoc file with "WARNING: Important notice"
  When the parser processes the file
  Then elements contains an entry of type "admonition"
  And admonition_type equals "WARNING"
----

=== AC-ADOC-08: Cross-Reference Capture

[source,gherkin]
----
Scenario: Cross-references are captured
  Given an AsciiDoc file with:
    """
    See <<section-a>> and xref:other.adoc#anchor[Link].
    """
  When the parser processes the file
  Then cross_references contains 2 entries
  And the first is type="internal", target="section-a"
  And the second is type="external", target="other.adoc#anchor"
----

=== AC-ADOC-09: Attribute Substitution in Include Paths

[source,gherkin]
----
Scenario: Attributes in include paths are resolved
  Given an AsciiDoc file with:
    """
    :chaptersdir: chapters

    \include::{chaptersdir}/intro.adoc[]
    """
  And a file "chapters/intro.adoc" exists
  When the parser processes the file
  Then "chapters/intro.adoc" is successfully included
----

== Interfaces

=== Parser Interface

[source,python]
----
class AsciidocParser:
    """Parser for AsciiDoc documents."""

    def __init__(self, base_path: Path, max_include_depth: int = 20):
        """
        Initializes the parser.

        Args:
            base_path: Base path for relative include resolution
            max_include_depth: Maximum include depth
        """
        ...

    def parse_file(self, file_path: Path) -> AsciidocDocument:
        """
        Parses an AsciiDoc file with include resolution.

        Raises:
            FileNotFoundError: File does not exist
            CircularIncludeError: Circular include detected
            IncludeNotFoundError: Include file not found
        """
        ...

    def get_section(self, doc: AsciidocDocument, path: str) -> AsciidocSection | None:
        """Finds a section by its hierarchical path."""
        ...

    def get_elements(
        self,
        doc: AsciidocDocument,
        element_type: str | None = None
    ) -> list[AsciidocElement]:
        """Returns all elements, optionally filtered by type."""
        ...

    def validate_cross_references(
        self,
        doc: AsciidocDocument
    ) -> list[ValidationError]:
        """Checks all cross-references for validity."""
        ...
----

== Implementation Notes

=== Regex Patterns

[source,python]
----
# Section (Level 0-5)
SECTION_PATTERN = r'^(={1,6})\s+(.+?)(?:\s+=*)?$'

# Document attribute
ATTRIBUTE_PATTERN = r'^:([a-zA-Z0-9_-]+):\s*(.*)$'

# Unset attribute
ATTRIBUTE_UNSET_PATTERN = r'^:!([a-zA-Z0-9_-]+):$'

# Attribute reference
ATTRIBUTE_REF_PATTERN = r'\{([a-zA-Z0-9_-]+)\}'

# Include directive
INCLUDE_PATTERN = r'^include::(.+?)\[(.*?)\]$'

# Source block start
SOURCE_BLOCK_PATTERN = r'^\[source(?:,\s*(\w+))?\]$'

# PlantUML block start
PLANTUML_PATTERN = r'^\[plantuml(?:,\s*([^,\]]+))?(?:,\s*(\w+))?\]$'

# Block delimiter
BLOCK_DELIMITER = r'^(-{4,}|={4,}|\*{4,}|_{4,})$'

# Block image
BLOCK_IMAGE_PATTERN = r'^image::(.+?)\[(.*)?]$'

# Admonition (short form)
ADMONITION_SHORT_PATTERN = r'^(NOTE|TIP|WARNING|CAUTION|IMPORTANT):\s*(.+)$'

# Cross-reference (internal)
XREF_INTERNAL_PATTERN = r'<<([^,>]+)(?:,([^>]+))?>>`

# Cross-reference (external)
XREF_EXTERNAL_PATTERN = r'xref:([^#\[]+)?(?:#([^\[]+))?\[([^\]]*)\]'

# Anchor
ANCHOR_PATTERN = r'^\[\[([^\]]+)\]\]$'

# Table start/end
TABLE_DELIMITER = r'^\|===$'
----

=== State Machine for Parsing

[plantuml, adoc-parser-states, svg]
----
@startuml
skinparam StateBackgroundColor LightYellow
skinparam StateBorderColor DarkOrange

[*] --> Header

Header --> Header : Attribute found
Header --> Content : First section or content

Content --> Section : = found
Content --> SourceBlock : [source,...] + ----
Content --> PlantUML : [plantuml,...] + ----
Content --> Table : |===
Content --> Admonition : NOTE:/TIP:/etc.
Content --> Include : include::
Content --> Content : Other lines

Section --> Content : Next line
SourceBlock --> SourceBlock : Content
SourceBlock --> Content : ----
PlantUML --> PlantUML : Content
PlantUML --> Content : ----
Table --> Table : Lines
Table --> Content : |===
Admonition --> Content : Next line
Include --> ResolveInclude : Load file
ResolveInclude --> Content : Back to main document

Content --> [*] : EOF
@enduml
----

=== Include Resolution Algorithm

[plantuml, include-resolution, svg]
----
@startuml
start
:Read include directive;
:Extract path and options;

:Substitute attributes in path;

if (Path in include stack?) then (yes)
  :Throw CircularIncludeError;
  stop
endif

:Add path to include stack;

if (File exists?) then (no)
  :Throw IncludeNotFoundError;
  stop
endif

:Load file content;

if (lines option present?) then (yes)
  :Extract specified lines;
endif

:Parse include content recursively;

if (leveloffset option present?) then (yes)
  :Adjust section level;
endif

:Insert parsed content;
:Set source location to original file;
:Remove path from include stack;

stop
@enduml
----
