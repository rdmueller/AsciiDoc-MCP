= dacli - Docs-As-Code CLI Specification
:toc:
:toclevels: 3

== Overview

`dacli` (Docs-As-Code CLI) enables the use of all documentation tools via the command line.
This is especially useful for LLMs that don't have MCP support but can use Bash/Shell tools.

== Global Options

[source,bash]
----
dacli [OPTIONS] <COMMAND> [ARGS]

Options:
  --docs-root PATH    Documentation root directory (default: $PROJECT_PATH or cwd)
  --format FORMAT     Output format: text (default), json, yaml
  --pretty            Formatted output for humans
  --verbose, -v       Show warning messages (default: only errors shown)
  --no-gitignore      Include files that would normally be excluded by .gitignore patterns
  --include-hidden    Include files in hidden directories (starting with '.')
  --version           Show version
  --help              Show help
----

== Help System

=== Command Groups

Commands are organized into story-based groups in the help output:

[cols="1,3"]
|===
| Group | Commands

| **Discover** | `structure`, `metadata` - Understand your documentation
| **Find** | `search`, `sections-at-level` - Locate specific content
| **Read** | `section`, `elements` - Access content details
| **Validate** | `validate` - Check documentation quality
| **Edit** | `update`, `insert` - Modify content
|===

=== Typo Correction

If you mistype a command, dacli suggests the correct command:

[source,bash]
----
$ dacli serch "API"
Error: No such command 'serch'.

Did you mean: search
----

=== Usage Examples

The main help (`dacli --help`) and each command help show usage examples:

[source,bash]
----
$ dacli --help
...
Examples:
  dacli --format json structure          # Get document structure as JSON
  dacli search "authentication"          # Find sections about authentication
  dacli section api.endpoints            # Read a specific section
----

== Command Aliases

For faster typing, all commands have short aliases:

[cols="1,2,3"]
|===
| Alias | Command | Description

| `str` | `structure` | Show document structure
| `meta` | `metadata` | Show project/section metadata
| `s` | `search` | Search documentation
| `lv` | `sections-at-level` | Sections at level N
| `sec` | `section` | Read section content
| `el` | `elements` | Get code/tables/images
| `val` | `validate` | Validate structure
|===

**Example:**
[source,bash]
----
# These are equivalent:
dacli --format json search "API"
dacli --format json s "API"
----

== Navigation Commands

=== structure

Shows the hierarchical document structure.

[source,bash]
----
dacli structure [--max-depth N]
----

**Example:**
[source,bash]
----
$ dacli structure --max-depth 1
{
  "sections": [
    {"path": "introduction", "title": "Introduction", "level": 1},
    {"path": "architecture", "title": "Architecture", "level": 1}
  ],
  "total_sections": 15
}
----

=== section

Reads the content of a section.

[source,bash]
----
dacli section <PATH>
----

**Example:**
[source,bash]
----
$ dacli section introduction.goals
{
  "path": "introduction.goals",
  "title": "Goals",
  "content": "== Goals\n\nThis section...",
  "format": "asciidoc"
}
----

=== sections-at-level

Shows all sections at a specific level.

[source,bash]
----
dacli sections-at-level <LEVEL>
----

== Search & Elements Commands

=== search

Searches the documentation.

[source,bash]
----
dacli search <QUERY> [--scope PATH] [--max-results N]
----

**Example:**
[source,bash]
----
$ dacli search "authentication" --max-results 5
{
  "query": "authentication",
  "results": [
    {"path": "security.auth", "context": "...implements authentication...", "score": 0.95}
  ],
  "total_results": 1
}
----

=== elements

Lists elements (code blocks, tables, etc.).

[source,bash]
----
dacli elements [SECTION_PATH] [--type TYPE] [--recursive]
----

**Arguments:**

* `SECTION_PATH`: Optional section path to filter elements (positional argument)

**Options:**

* `--type TYPE`: Element type filter - `code`, `table`, `image`, `diagram`, `list`, `admonition`
* `--recursive`: Include elements from child sections (default: exact match only)

== Meta-Information Commands

=== metadata

Shows metadata for project or section.

[source,bash]
----
dacli metadata [PATH]
----

**Project metadata (without PATH):**
[source,bash]
----
$ dacli metadata
{
  "total_files": 15,
  "total_sections": 87,
  "total_words": 12450,
  "formats": ["asciidoc", "markdown"]
}
----

**Section metadata (with PATH):**
[source,bash]
----
$ dacli metadata architecture.decisions
{
  "path": "architecture.decisions",
  "title": "Architecture Decisions",
  "word_count": 2340,
  "subsection_count": 5
}
----

=== validate

Validates the documentation structure.

[source,bash]
----
dacli validate
----

**Example:**
[source,bash]
----
$ dacli validate
{
  "valid": true,
  "errors": [],
  "warnings": [
    {"type": "orphaned_file", "path": "unused.adoc"}
  ],
  "validation_time_ms": 45
}
----

== Manipulation Commands

=== update

Updates the content of a section.

[source,bash]
----
dacli update <PATH> --content "..." [--no-preserve-title] [--expected-hash HASH]
----

**Content Input:**

* Direct string: `--content "New content here"`
* Escape sequences: `--content "Line 1\nLine 2"` (converts `\n` to actual newlines)
* From stdin: `--content -` (reads from stdin)

**Examples:**
[source,bash]
----
# Direct content with escape sequences
$ dacli update introduction --content "First paragraph.\n\nSecond paragraph."
{
  "success": true,
  "path": "introduction",
  "previous_hash": "a1b2c3d4",
  "new_hash": "e5f6g7h8"
}

# Read content from stdin (useful for multi-line content)
$ cat new_content.txt | dacli update introduction --content -

# Pipe from another command
$ echo "Updated via stdin" | dacli update introduction --content -
----

=== insert

Inserts content relative to a section.

[source,bash]
----
dacli insert <PATH> --position before|after|append --content "..."
----

**Position Options:**

* `before` - Insert before the section heading
* `after` - Insert after the section content (before next sibling)
* `append` - Insert at end of section, after all subsections

**Content Input:**

* Direct string: `--content "New content"`
* Escape sequences: `--content "## Section\n\nContent"` (converts `\n` to newlines)
* From stdin: `--content -` (reads from stdin)

NOTE: When inserting content that starts with a heading (`#` or `=`) after existing content, a blank line is automatically added for proper formatting.

**Examples:**
[source,bash]
----
# Insert new section with escape sequences
$ dacli insert architecture --position after --content "== New Section\n\nContent..."
{
  "success": true,
  "inserted_at": {"file": "arc42.adoc", "line": 150}
}

# Insert from stdin (for complex multi-line content)
$ cat new_section.adoc | dacli insert architecture --position after --content -

# Append to end of parent section (after all subsections)
$ dacli insert components --position append --content "=== New Component\n\nDetails..."
----

== Exit Codes

[cols="1,3"]
|===
| Code | Meaning

| 0 | Success
| 1 | General error
| 2 | Invalid arguments
| 3 | Path not found
| 4 | Validation error
| 5 | Write error
|===

== LLM Integration Example

An LLM can use the CLI via Bash tools:

[source,bash]
----
# Query structure
structure=$(dacli structure --max-depth 2 --docs-root /project/docs)

# Search for topic
results=$(dacli search "database" | jq '.results[].path')

# Read section
content=$(dacli section architecture.decisions)

# Update documentation
dacli update api.endpoints --content "Updated API documentation..."
----
